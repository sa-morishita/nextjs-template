直前のコミットから重要なテストを提案します

---
allowed-tools: ["Bash", "Read", "Glob", "Grep", "TodoWrite"]
description: "直前のコミットの変更内容を分析し、既存のテストパターンに基づいて実装すべきテストを提案"
---

# suggest-tests-from-commit

直前のコミットの変更内容を分析し、プロジェクトの既存テストパターンに基づいて、実装すべき重要なテストを提案します。

## Instructions

1. 直前のコミット内容を分析
   !git log -1 --name-status --pretty=format:"%h %s"
   !git diff HEAD~1 HEAD --stat
   !git diff HEAD~1 HEAD --name-only

2. 変更されたファイルの詳細を確認
   - 各変更ファイルの差分を読み取る
   - 新規追加/修正された機能を特定

3. 既存のテストパターンを調査
   - **ユニットテスト**: フォームバリデーションに特化
     - パターン検索: **/*.test.ts, **/*.test.tsx
     - 特にフォーム関連のテストを参照
   - **結合テスト**: 優先順位順に
     - 1. **usecases** (最優先・必須): **/*usecase*.integration.test.ts
     - 2. **queries**: **/*query*.integration.test.ts
     - 3. **mutations**: **/*mutation*.integration.test.ts
     - 4. **services**: **/*service*.integration.test.ts
     - 既存のテスト構造とモック方法を確認

4. テスト提案の作成（TodoWriteツールを使用）
   以下の基準で重要なテストを選定：
   - **最優先**: usecaseが追加/変更された場合 → 必ず結合テスト
   - フォームが追加/変更された場合 → バリデーションのユニットテスト
   - query/mutationが追加/変更された場合 → 結合テスト
   - servicesが追加/変更された場合 → 外部サービスのモック方法を検討

5. 実装方針の提案（コードは書かない）
   - 既存のテストファイルの命名規則と配置場所
   - 使用すべきテストパターン（既存のテストを参考）
   - モックの方法（特にservicesの外部サービス）
   - テストケースの優先順位

## 出力形式

### 1. コミット内容の要約
- 変更されたファイルと機能の概要

### 2. 推奨テスト一覧
優先度順に以下を含める：
- テストタイプ（ユニット/結合）
- テスト対象（ファイル/関数）
- テストすべき内容
- 参考にすべき既存テスト

### 3. 実装方針
- ファイル配置
- 既存パターンの活用方法
- **servicesのテスト方法**:
  - 外部サービスのモック戦略
  - テスト可能性の検証
  - 既存のserviceテストパターンの有無
- 注意点

## 注意事項

- 少人数プロジェクトなので、重要なテストのみに絞る
- 独自性は不要、既存のテストパターンに完全に準拠
- コードは生成せず、方針の提案のみ
- **結合テストの優先順位**: usecase(必須) > query/mutation > services
- servicesの外部サービステストは実現可能性を慎重に検討